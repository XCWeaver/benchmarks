// Code generated by "xcweaver generate". DO NOT EDIT.
//go:build !ignoreWeaverGen

package services

import (
	"context"
	"errors"
	"github.com/TiagoMalhadas/xcweaver"
	"github.com/TiagoMalhadas/xcweaver/runtime/codegen"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
	"reflect"
	"trainticket/pkg/model"
)

func init() {
	codegen.Register(codegen.Registration{
		Name:  "trainticket/pkg/services/AdminBasicInfoService",
		Iface: reflect.TypeOf((*AdminBasicInfoService)(nil)).Elem(),
		Impl:  reflect.TypeOf(adminBasicInfoService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return adminBasicInfoService_local_stub{impl: impl.(AdminBasicInfoService), tracer: tracer, addContactsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminBasicInfoService", Method: "AddContacts", Remote: false}), addPriceMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminBasicInfoService", Method: "AddPrice", Remote: false}), addTrainMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminBasicInfoService", Method: "AddTrain", Remote: false}), deleteContactsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminBasicInfoService", Method: "DeleteContacts", Remote: false}), deleteTrainMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminBasicInfoService", Method: "DeleteTrain", Remote: false}), getAllContactsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminBasicInfoService", Method: "GetAllContacts", Remote: false}), getAllTrainsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminBasicInfoService", Method: "GetAllTrains", Remote: false}), modifyContactsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminBasicInfoService", Method: "ModifyContacts", Remote: false}), modifyTrainMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminBasicInfoService", Method: "ModifyTrain", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return adminBasicInfoService_client_stub{stub: stub, addContactsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminBasicInfoService", Method: "AddContacts", Remote: true}), addPriceMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminBasicInfoService", Method: "AddPrice", Remote: true}), addTrainMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminBasicInfoService", Method: "AddTrain", Remote: true}), deleteContactsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminBasicInfoService", Method: "DeleteContacts", Remote: true}), deleteTrainMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminBasicInfoService", Method: "DeleteTrain", Remote: true}), getAllContactsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminBasicInfoService", Method: "GetAllContacts", Remote: true}), getAllTrainsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminBasicInfoService", Method: "GetAllTrains", Remote: true}), modifyContactsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminBasicInfoService", Method: "ModifyContacts", Remote: true}), modifyTrainMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminBasicInfoService", Method: "ModifyTrain", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return adminBasicInfoService_server_stub{impl: impl.(AdminBasicInfoService), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return adminBasicInfoService_reflect_stub{caller: caller}
		},
		RefData: "⟦2c525e2d:wEaVeReDgE:trainticket/pkg/services/AdminBasicInfoService→trainticket/pkg/services/TrainService⟧\n⟦852e4b8f:wEaVeReDgE:trainticket/pkg/services/AdminBasicInfoService→trainticket/pkg/services/PriceService⟧\n⟦a3ebb374:wEaVeReDgE:trainticket/pkg/services/AdminBasicInfoService→trainticket/pkg/services/ContactService⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:  "trainticket/pkg/services/AdminOrderService",
		Iface: reflect.TypeOf((*AdminOrderService)(nil)).Elem(),
		Impl:  reflect.TypeOf(adminOrderService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return adminOrderService_local_stub{impl: impl.(AdminOrderService), tracer: tracer}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any { return adminOrderService_client_stub{stub: stub} },
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return adminOrderService_server_stub{impl: impl.(AdminOrderService), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return adminOrderService_reflect_stub{caller: caller}
		},
		RefData: "⟦588982f8:wEaVeReDgE:trainticket/pkg/services/AdminOrderService→trainticket/pkg/services/OrderService⟧\n⟦b12dbbd0:wEaVeReDgE:trainticket/pkg/services/AdminOrderService→trainticket/pkg/services/OrderOtherService⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:  "trainticket/pkg/services/AdminUserService",
		Iface: reflect.TypeOf((*AdminUserService)(nil)).Elem(),
		Impl:  reflect.TypeOf(adminUserService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return adminUserService_local_stub{impl: impl.(AdminUserService), tracer: tracer, addUserMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminUserService", Method: "AddUser", Remote: false}), deleteUserMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminUserService", Method: "DeleteUser", Remote: false}), getAllUsersMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminUserService", Method: "GetAllUsers", Remote: false}), updateUserMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminUserService", Method: "UpdateUser", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return adminUserService_client_stub{stub: stub, addUserMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminUserService", Method: "AddUser", Remote: true}), deleteUserMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminUserService", Method: "DeleteUser", Remote: true}), getAllUsersMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminUserService", Method: "GetAllUsers", Remote: true}), updateUserMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AdminUserService", Method: "UpdateUser", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return adminUserService_server_stub{impl: impl.(AdminUserService), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return adminUserService_reflect_stub{caller: caller}
		},
		RefData: "⟦e0e9f8d2:wEaVeReDgE:trainticket/pkg/services/AdminUserService→trainticket/pkg/services/UserService⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:  "trainticket/pkg/services/AuthService",
		Iface: reflect.TypeOf((*AuthService)(nil)).Elem(),
		Impl:  reflect.TypeOf(authService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return authService_local_stub{impl: impl.(AuthService), tracer: tracer, createDefaultUserMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AuthService", Method: "CreateDefaultUser", Remote: false}), loginMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AuthService", Method: "Login", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return authService_client_stub{stub: stub, createDefaultUserMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AuthService", Method: "CreateDefaultUser", Remote: true}), loginMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/AuthService", Method: "Login", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return authService_server_stub{impl: impl.(AuthService), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return authService_reflect_stub{caller: caller}
		},
		RefData: "",
	})
	codegen.Register(codegen.Registration{
		Name:  "trainticket/pkg/services/CancelService",
		Iface: reflect.TypeOf((*CancelService)(nil)).Elem(),
		Impl:  reflect.TypeOf(cancelService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return cancelService_local_stub{impl: impl.(CancelService), tracer: tracer, calculateMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/CancelService", Method: "Calculate", Remote: false}), cancelTicketMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/CancelService", Method: "CancelTicket", Remote: false}), getConsistencyWindowValuesMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/CancelService", Method: "GetConsistencyWindowValues", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return cancelService_client_stub{stub: stub, calculateMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/CancelService", Method: "Calculate", Remote: true}), cancelTicketMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/CancelService", Method: "CancelTicket", Remote: true}), getConsistencyWindowValuesMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/CancelService", Method: "GetConsistencyWindowValues", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return cancelService_server_stub{impl: impl.(CancelService), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return cancelService_reflect_stub{caller: caller}
		},
		RefData: "⟦1cdefd5f:wEaVeReDgE:trainticket/pkg/services/CancelService→trainticket/pkg/services/OrderService⟧\n⟦e3e9ea5a:wEaVeReDgE:trainticket/pkg/services/CancelService→trainticket/pkg/services/OrderOtherService⟧\n⟦6bdfb640:wEaVeReDgE:trainticket/pkg/services/CancelService→trainticket/pkg/services/InsidePaymentService⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:  "trainticket/pkg/services/ContactService",
		Iface: reflect.TypeOf((*ContactService)(nil)).Elem(),
		Impl:  reflect.TypeOf(contactService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return contactService_local_stub{impl: impl.(ContactService), tracer: tracer, createNewContactsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/ContactService", Method: "CreateNewContacts", Remote: false}), createNewContactsAdminMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/ContactService", Method: "CreateNewContactsAdmin", Remote: false}), deleteContactsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/ContactService", Method: "DeleteContacts", Remote: false}), findContactsByAccountIdMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/ContactService", Method: "FindContactsByAccountId", Remote: false}), getAllContactsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/ContactService", Method: "GetAllContacts", Remote: false}), getContactsByContactIdMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/ContactService", Method: "GetContactsByContactId", Remote: false}), modifyContactsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/ContactService", Method: "ModifyContacts", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return contactService_client_stub{stub: stub, createNewContactsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/ContactService", Method: "CreateNewContacts", Remote: true}), createNewContactsAdminMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/ContactService", Method: "CreateNewContactsAdmin", Remote: true}), deleteContactsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/ContactService", Method: "DeleteContacts", Remote: true}), findContactsByAccountIdMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/ContactService", Method: "FindContactsByAccountId", Remote: true}), getAllContactsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/ContactService", Method: "GetAllContacts", Remote: true}), getContactsByContactIdMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/ContactService", Method: "GetContactsByContactId", Remote: true}), modifyContactsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/ContactService", Method: "ModifyContacts", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return contactService_server_stub{impl: impl.(ContactService), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return contactService_reflect_stub{caller: caller}
		},
		RefData: "",
	})
	codegen.Register(codegen.Registration{
		Name:  "trainticket/pkg/services/InsidePaymentService",
		Iface: reflect.TypeOf((*InsidePaymentService)(nil)).Elem(),
		Impl:  reflect.TypeOf(insidePaymentService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return insidePaymentService_local_stub{impl: impl.(InsidePaymentService), tracer: tracer, drawBackMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/InsidePaymentService", Method: "DrawBack", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return insidePaymentService_client_stub{stub: stub, drawBackMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/InsidePaymentService", Method: "DrawBack", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return insidePaymentService_server_stub{impl: impl.(InsidePaymentService), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return insidePaymentService_reflect_stub{caller: caller}
		},
		RefData: "⟦950adffe:wEaVeReDgE:trainticket/pkg/services/InsidePaymentService→trainticket/pkg/services/OrderService⟧\n⟦18df40b9:wEaVeReDgE:trainticket/pkg/services/InsidePaymentService→trainticket/pkg/services/OrderOtherService⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:  "trainticket/pkg/services/NotificationService",
		Iface: reflect.TypeOf((*NotificationService)(nil)).Elem(),
		Impl:  reflect.TypeOf(notificationService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return notificationService_local_stub{impl: impl.(NotificationService), tracer: tracer, orderCancelSuccessMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/NotificationService", Method: "OrderCancelSuccess", Remote: false}), orderChangedSuccessMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/NotificationService", Method: "OrderChangedSuccess", Remote: false}), orderCreateSuccessMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/NotificationService", Method: "OrderCreateSuccess", Remote: false}), preserveSuccessMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/NotificationService", Method: "PreserveSuccess", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return notificationService_client_stub{stub: stub, orderCancelSuccessMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/NotificationService", Method: "OrderCancelSuccess", Remote: true}), orderChangedSuccessMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/NotificationService", Method: "OrderChangedSuccess", Remote: true}), orderCreateSuccessMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/NotificationService", Method: "OrderCreateSuccess", Remote: true}), preserveSuccessMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/NotificationService", Method: "PreserveSuccess", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return notificationService_server_stub{impl: impl.(NotificationService), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return notificationService_reflect_stub{caller: caller}
		},
		RefData: "",
	})
	codegen.Register(codegen.Registration{
		Name:  "trainticket/pkg/services/OrderOtherService",
		Iface: reflect.TypeOf((*OrderOtherService)(nil)).Elem(),
		Impl:  reflect.TypeOf(orderOtherService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return orderOtherService_local_stub{impl: impl.(OrderOtherService), tracer: tracer, getOrderByIdMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/OrderOtherService", Method: "GetOrderById", Remote: false}), modifyOrderMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/OrderOtherService", Method: "ModifyOrder", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return orderOtherService_client_stub{stub: stub, getOrderByIdMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/OrderOtherService", Method: "GetOrderById", Remote: true}), modifyOrderMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/OrderOtherService", Method: "ModifyOrder", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return orderOtherService_server_stub{impl: impl.(OrderOtherService), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return orderOtherService_reflect_stub{caller: caller}
		},
		RefData: "",
	})
	codegen.Register(codegen.Registration{
		Name:  "trainticket/pkg/services/OrderService",
		Iface: reflect.TypeOf((*OrderService)(nil)).Elem(),
		Impl:  reflect.TypeOf(orderService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return orderService_local_stub{impl: impl.(OrderService), tracer: tracer, getOrderByIdMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/OrderService", Method: "GetOrderById", Remote: false}), modifyOrderMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/OrderService", Method: "ModifyOrder", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return orderService_client_stub{stub: stub, getOrderByIdMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/OrderService", Method: "GetOrderById", Remote: true}), modifyOrderMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/OrderService", Method: "ModifyOrder", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return orderService_server_stub{impl: impl.(OrderService), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return orderService_reflect_stub{caller: caller}
		},
		RefData: "",
	})
	codegen.Register(codegen.Registration{
		Name:  "trainticket/pkg/services/PaymentService",
		Iface: reflect.TypeOf((*PaymentService)(nil)).Elem(),
		Impl:  reflect.TypeOf(paymentService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return paymentService_local_stub{impl: impl.(PaymentService), tracer: tracer, payMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/PaymentService", Method: "Pay", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return paymentService_client_stub{stub: stub, payMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/PaymentService", Method: "Pay", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return paymentService_server_stub{impl: impl.(PaymentService), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return paymentService_reflect_stub{caller: caller}
		},
		RefData: "",
	})
	codegen.Register(codegen.Registration{
		Name:  "trainticket/pkg/services/PriceService",
		Iface: reflect.TypeOf((*PriceService)(nil)).Elem(),
		Impl:  reflect.TypeOf(priceService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return priceService_local_stub{impl: impl.(PriceService), tracer: tracer, createMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/PriceService", Method: "Create", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return priceService_client_stub{stub: stub, createMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/PriceService", Method: "Create", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return priceService_server_stub{impl: impl.(PriceService), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return priceService_reflect_stub{caller: caller}
		},
		RefData: "",
	})
	codegen.Register(codegen.Registration{
		Name:  "trainticket/pkg/services/TrainService",
		Iface: reflect.TypeOf((*TrainService)(nil)).Elem(),
		Impl:  reflect.TypeOf(trainService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return trainService_local_stub{impl: impl.(TrainService), tracer: tracer, createMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/TrainService", Method: "Create", Remote: false}), deleteMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/TrainService", Method: "Delete", Remote: false}), queryMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/TrainService", Method: "Query", Remote: false}), retrieveMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/TrainService", Method: "Retrieve", Remote: false}), updateMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/TrainService", Method: "Update", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return trainService_client_stub{stub: stub, createMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/TrainService", Method: "Create", Remote: true}), deleteMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/TrainService", Method: "Delete", Remote: true}), queryMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/TrainService", Method: "Query", Remote: true}), retrieveMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/TrainService", Method: "Retrieve", Remote: true}), updateMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/TrainService", Method: "Update", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return trainService_server_stub{impl: impl.(TrainService), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return trainService_reflect_stub{caller: caller}
		},
		RefData: "",
	})
	codegen.Register(codegen.Registration{
		Name:  "trainticket/pkg/services/UserService",
		Iface: reflect.TypeOf((*UserService)(nil)).Elem(),
		Impl:  reflect.TypeOf(userService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return userService_local_stub{impl: impl.(UserService), tracer: tracer, deleteUserByIdMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/UserService", Method: "DeleteUserById", Remote: false}), getAllUsersMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/UserService", Method: "GetAllUsers", Remote: false}), getUserByIdMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/UserService", Method: "GetUserById", Remote: false}), getUserByUsernameMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/UserService", Method: "GetUserByUsername", Remote: false}), registerUserMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/UserService", Method: "RegisterUser", Remote: false}), updateUserMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/UserService", Method: "UpdateUser", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return userService_client_stub{stub: stub, deleteUserByIdMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/UserService", Method: "DeleteUserById", Remote: true}), getAllUsersMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/UserService", Method: "GetAllUsers", Remote: true}), getUserByIdMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/UserService", Method: "GetUserById", Remote: true}), getUserByUsernameMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/UserService", Method: "GetUserByUsername", Remote: true}), registerUserMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/UserService", Method: "RegisterUser", Remote: true}), updateUserMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "trainticket/pkg/services/UserService", Method: "UpdateUser", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return userService_server_stub{impl: impl.(UserService), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return userService_reflect_stub{caller: caller}
		},
		RefData: "⟦03234547:wEaVeReDgE:trainticket/pkg/services/UserService→trainticket/pkg/services/AuthService⟧\n",
	})
}

// xcweaver.InstanceOf checks.
var _ xcweaver.InstanceOf[AdminBasicInfoService] = (*adminBasicInfoService)(nil)
var _ xcweaver.InstanceOf[AdminOrderService] = (*adminOrderService)(nil)
var _ xcweaver.InstanceOf[AdminUserService] = (*adminUserService)(nil)
var _ xcweaver.InstanceOf[AuthService] = (*authService)(nil)
var _ xcweaver.InstanceOf[CancelService] = (*cancelService)(nil)
var _ xcweaver.InstanceOf[ContactService] = (*contactService)(nil)
var _ xcweaver.InstanceOf[InsidePaymentService] = (*insidePaymentService)(nil)
var _ xcweaver.InstanceOf[NotificationService] = (*notificationService)(nil)
var _ xcweaver.InstanceOf[OrderOtherService] = (*orderOtherService)(nil)
var _ xcweaver.InstanceOf[OrderService] = (*orderService)(nil)
var _ xcweaver.InstanceOf[PaymentService] = (*paymentService)(nil)
var _ xcweaver.InstanceOf[PriceService] = (*priceService)(nil)
var _ xcweaver.InstanceOf[TrainService] = (*trainService)(nil)
var _ xcweaver.InstanceOf[UserService] = (*userService)(nil)

// xcweaver.Router checks.
var _ xcweaver.Unrouted = (*adminBasicInfoService)(nil)
var _ xcweaver.Unrouted = (*adminOrderService)(nil)
var _ xcweaver.Unrouted = (*adminUserService)(nil)
var _ xcweaver.Unrouted = (*authService)(nil)
var _ xcweaver.Unrouted = (*cancelService)(nil)
var _ xcweaver.Unrouted = (*contactService)(nil)
var _ xcweaver.Unrouted = (*insidePaymentService)(nil)
var _ xcweaver.Unrouted = (*notificationService)(nil)
var _ xcweaver.Unrouted = (*orderOtherService)(nil)
var _ xcweaver.Unrouted = (*orderService)(nil)
var _ xcweaver.Unrouted = (*paymentService)(nil)
var _ xcweaver.Unrouted = (*priceService)(nil)
var _ xcweaver.Unrouted = (*trainService)(nil)
var _ xcweaver.Unrouted = (*userService)(nil)

// Local stub implementations.

type adminBasicInfoService_local_stub struct {
	impl                  AdminBasicInfoService
	tracer                trace.Tracer
	addContactsMetrics    *codegen.MethodMetrics
	addPriceMetrics       *codegen.MethodMetrics
	addTrainMetrics       *codegen.MethodMetrics
	deleteContactsMetrics *codegen.MethodMetrics
	deleteTrainMetrics    *codegen.MethodMetrics
	getAllContactsMetrics *codegen.MethodMetrics
	getAllTrainsMetrics   *codegen.MethodMetrics
	modifyContactsMetrics *codegen.MethodMetrics
	modifyTrainMetrics    *codegen.MethodMetrics
}

// Check that adminBasicInfoService_local_stub implements the AdminBasicInfoService interface.
var _ AdminBasicInfoService = (*adminBasicInfoService_local_stub)(nil)

func (s adminBasicInfoService_local_stub) AddContacts(ctx context.Context, a0 model.Contact, a1 string) (r0 model.Contact, err error) {
	// Update metrics.
	begin := s.addContactsMetrics.Begin()
	defer func() { s.addContactsMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.AdminBasicInfoService.AddContacts", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.AddContacts(ctx, a0, a1)
}

func (s adminBasicInfoService_local_stub) AddPrice(ctx context.Context, a0 model.PriceConfig, a1 string) (r0 model.PriceConfig, err error) {
	// Update metrics.
	begin := s.addPriceMetrics.Begin()
	defer func() { s.addPriceMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.AdminBasicInfoService.AddPrice", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.AddPrice(ctx, a0, a1)
}

func (s adminBasicInfoService_local_stub) AddTrain(ctx context.Context, a0 model.Train, a1 string) (r0 model.Train, err error) {
	// Update metrics.
	begin := s.addTrainMetrics.Begin()
	defer func() { s.addTrainMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.AdminBasicInfoService.AddTrain", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.AddTrain(ctx, a0, a1)
}

func (s adminBasicInfoService_local_stub) DeleteContacts(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	// Update metrics.
	begin := s.deleteContactsMetrics.Begin()
	defer func() { s.deleteContactsMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.AdminBasicInfoService.DeleteContacts", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.DeleteContacts(ctx, a0, a1)
}

func (s adminBasicInfoService_local_stub) DeleteTrain(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	// Update metrics.
	begin := s.deleteTrainMetrics.Begin()
	defer func() { s.deleteTrainMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.AdminBasicInfoService.DeleteTrain", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.DeleteTrain(ctx, a0, a1)
}

func (s adminBasicInfoService_local_stub) GetAllContacts(ctx context.Context, a0 string) (r0 []model.Contact, err error) {
	// Update metrics.
	begin := s.getAllContactsMetrics.Begin()
	defer func() { s.getAllContactsMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.AdminBasicInfoService.GetAllContacts", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetAllContacts(ctx, a0)
}

func (s adminBasicInfoService_local_stub) GetAllTrains(ctx context.Context, a0 string) (r0 []model.Train, err error) {
	// Update metrics.
	begin := s.getAllTrainsMetrics.Begin()
	defer func() { s.getAllTrainsMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.AdminBasicInfoService.GetAllTrains", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetAllTrains(ctx, a0)
}

func (s adminBasicInfoService_local_stub) ModifyContacts(ctx context.Context, a0 model.Contact, a1 string) (r0 model.Contact, err error) {
	// Update metrics.
	begin := s.modifyContactsMetrics.Begin()
	defer func() { s.modifyContactsMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.AdminBasicInfoService.ModifyContacts", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.ModifyContacts(ctx, a0, a1)
}

func (s adminBasicInfoService_local_stub) ModifyTrain(ctx context.Context, a0 model.Train, a1 string) (r0 model.Train, err error) {
	// Update metrics.
	begin := s.modifyTrainMetrics.Begin()
	defer func() { s.modifyTrainMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.AdminBasicInfoService.ModifyTrain", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.ModifyTrain(ctx, a0, a1)
}

type adminOrderService_local_stub struct {
	impl   AdminOrderService
	tracer trace.Tracer
}

// Check that adminOrderService_local_stub implements the AdminOrderService interface.
var _ AdminOrderService = (*adminOrderService_local_stub)(nil)

type adminUserService_local_stub struct {
	impl               AdminUserService
	tracer             trace.Tracer
	addUserMetrics     *codegen.MethodMetrics
	deleteUserMetrics  *codegen.MethodMetrics
	getAllUsersMetrics *codegen.MethodMetrics
	updateUserMetrics  *codegen.MethodMetrics
}

// Check that adminUserService_local_stub implements the AdminUserService interface.
var _ AdminUserService = (*adminUserService_local_stub)(nil)

func (s adminUserService_local_stub) AddUser(ctx context.Context, a0 model.User, a1 string) (r0 model.User, err error) {
	// Update metrics.
	begin := s.addUserMetrics.Begin()
	defer func() { s.addUserMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.AdminUserService.AddUser", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.AddUser(ctx, a0, a1)
}

func (s adminUserService_local_stub) DeleteUser(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	// Update metrics.
	begin := s.deleteUserMetrics.Begin()
	defer func() { s.deleteUserMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.AdminUserService.DeleteUser", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.DeleteUser(ctx, a0, a1)
}

func (s adminUserService_local_stub) GetAllUsers(ctx context.Context, a0 string) (r0 []model.User, err error) {
	// Update metrics.
	begin := s.getAllUsersMetrics.Begin()
	defer func() { s.getAllUsersMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.AdminUserService.GetAllUsers", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetAllUsers(ctx, a0)
}

func (s adminUserService_local_stub) UpdateUser(ctx context.Context, a0 model.User, a1 string) (r0 model.User, err error) {
	// Update metrics.
	begin := s.updateUserMetrics.Begin()
	defer func() { s.updateUserMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.AdminUserService.UpdateUser", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.UpdateUser(ctx, a0, a1)
}

type authService_local_stub struct {
	impl                     AuthService
	tracer                   trace.Tracer
	createDefaultUserMetrics *codegen.MethodMetrics
	loginMetrics             *codegen.MethodMetrics
}

// Check that authService_local_stub implements the AuthService interface.
var _ AuthService = (*authService_local_stub)(nil)

func (s authService_local_stub) CreateDefaultUser(ctx context.Context, a0 model.User, a1 string) (r0 string, err error) {
	// Update metrics.
	begin := s.createDefaultUserMetrics.Begin()
	defer func() { s.createDefaultUserMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.AuthService.CreateDefaultUser", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.CreateDefaultUser(ctx, a0, a1)
}

func (s authService_local_stub) Login(ctx context.Context, a0 string, a1 string, a2 string, a3 model.Captcha) (r0 string, err error) {
	// Update metrics.
	begin := s.loginMetrics.Begin()
	defer func() { s.loginMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.AuthService.Login", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.Login(ctx, a0, a1, a2, a3)
}

type cancelService_local_stub struct {
	impl                              CancelService
	tracer                            trace.Tracer
	calculateMetrics                  *codegen.MethodMetrics
	cancelTicketMetrics               *codegen.MethodMetrics
	getConsistencyWindowValuesMetrics *codegen.MethodMetrics
}

// Check that cancelService_local_stub implements the CancelService interface.
var _ CancelService = (*cancelService_local_stub)(nil)

func (s cancelService_local_stub) Calculate(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	// Update metrics.
	begin := s.calculateMetrics.Begin()
	defer func() { s.calculateMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.CancelService.Calculate", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.Calculate(ctx, a0, a1)
}

func (s cancelService_local_stub) CancelTicket(ctx context.Context, a0 string, a1 string, a2 string) (r0 string, err error) {
	// Update metrics.
	begin := s.cancelTicketMetrics.Begin()
	defer func() { s.cancelTicketMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.CancelService.CancelTicket", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.CancelTicket(ctx, a0, a1, a2)
}

func (s cancelService_local_stub) GetConsistencyWindowValues(ctx context.Context) (r0 []float64, err error) {
	// Update metrics.
	begin := s.getConsistencyWindowValuesMetrics.Begin()
	defer func() { s.getConsistencyWindowValuesMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.CancelService.GetConsistencyWindowValues", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetConsistencyWindowValues(ctx)
}

type contactService_local_stub struct {
	impl                           ContactService
	tracer                         trace.Tracer
	createNewContactsMetrics       *codegen.MethodMetrics
	createNewContactsAdminMetrics  *codegen.MethodMetrics
	deleteContactsMetrics          *codegen.MethodMetrics
	findContactsByAccountIdMetrics *codegen.MethodMetrics
	getAllContactsMetrics          *codegen.MethodMetrics
	getContactsByContactIdMetrics  *codegen.MethodMetrics
	modifyContactsMetrics          *codegen.MethodMetrics
}

// Check that contactService_local_stub implements the ContactService interface.
var _ ContactService = (*contactService_local_stub)(nil)

func (s contactService_local_stub) CreateNewContacts(ctx context.Context, a0 model.Contact, a1 string) (r0 model.Contact, err error) {
	// Update metrics.
	begin := s.createNewContactsMetrics.Begin()
	defer func() { s.createNewContactsMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.ContactService.CreateNewContacts", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.CreateNewContacts(ctx, a0, a1)
}

func (s contactService_local_stub) CreateNewContactsAdmin(ctx context.Context, a0 model.Contact, a1 string) (r0 model.Contact, err error) {
	// Update metrics.
	begin := s.createNewContactsAdminMetrics.Begin()
	defer func() { s.createNewContactsAdminMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.ContactService.CreateNewContactsAdmin", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.CreateNewContactsAdmin(ctx, a0, a1)
}

func (s contactService_local_stub) DeleteContacts(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	// Update metrics.
	begin := s.deleteContactsMetrics.Begin()
	defer func() { s.deleteContactsMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.ContactService.DeleteContacts", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.DeleteContacts(ctx, a0, a1)
}

func (s contactService_local_stub) FindContactsByAccountId(ctx context.Context, a0 string, a1 string) (r0 []model.Contact, err error) {
	// Update metrics.
	begin := s.findContactsByAccountIdMetrics.Begin()
	defer func() { s.findContactsByAccountIdMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.ContactService.FindContactsByAccountId", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.FindContactsByAccountId(ctx, a0, a1)
}

func (s contactService_local_stub) GetAllContacts(ctx context.Context, a0 string) (r0 []model.Contact, err error) {
	// Update metrics.
	begin := s.getAllContactsMetrics.Begin()
	defer func() { s.getAllContactsMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.ContactService.GetAllContacts", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetAllContacts(ctx, a0)
}

func (s contactService_local_stub) GetContactsByContactId(ctx context.Context, a0 string, a1 string) (r0 model.Contact, err error) {
	// Update metrics.
	begin := s.getContactsByContactIdMetrics.Begin()
	defer func() { s.getContactsByContactIdMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.ContactService.GetContactsByContactId", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetContactsByContactId(ctx, a0, a1)
}

func (s contactService_local_stub) ModifyContacts(ctx context.Context, a0 model.Contact, a1 string) (r0 model.Contact, err error) {
	// Update metrics.
	begin := s.modifyContactsMetrics.Begin()
	defer func() { s.modifyContactsMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.ContactService.ModifyContacts", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.ModifyContacts(ctx, a0, a1)
}

type insidePaymentService_local_stub struct {
	impl            InsidePaymentService
	tracer          trace.Tracer
	drawBackMetrics *codegen.MethodMetrics
}

// Check that insidePaymentService_local_stub implements the InsidePaymentService interface.
var _ InsidePaymentService = (*insidePaymentService_local_stub)(nil)

func (s insidePaymentService_local_stub) DrawBack(ctx context.Context, a0 string, a1 string, a2 string) (r0 string, err error) {
	// Update metrics.
	begin := s.drawBackMetrics.Begin()
	defer func() { s.drawBackMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.InsidePaymentService.DrawBack", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.DrawBack(ctx, a0, a1, a2)
}

type notificationService_local_stub struct {
	impl                       NotificationService
	tracer                     trace.Tracer
	orderCancelSuccessMetrics  *codegen.MethodMetrics
	orderChangedSuccessMetrics *codegen.MethodMetrics
	orderCreateSuccessMetrics  *codegen.MethodMetrics
	preserveSuccessMetrics     *codegen.MethodMetrics
}

// Check that notificationService_local_stub implements the NotificationService interface.
var _ NotificationService = (*notificationService_local_stub)(nil)

func (s notificationService_local_stub) OrderCancelSuccess(ctx context.Context, a0 model.NotificationInfo, a1 string) (err error) {
	// Update metrics.
	begin := s.orderCancelSuccessMetrics.Begin()
	defer func() { s.orderCancelSuccessMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.NotificationService.OrderCancelSuccess", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.OrderCancelSuccess(ctx, a0, a1)
}

func (s notificationService_local_stub) OrderChangedSuccess(ctx context.Context, a0 model.NotificationInfo, a1 string) (err error) {
	// Update metrics.
	begin := s.orderChangedSuccessMetrics.Begin()
	defer func() { s.orderChangedSuccessMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.NotificationService.OrderChangedSuccess", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.OrderChangedSuccess(ctx, a0, a1)
}

func (s notificationService_local_stub) OrderCreateSuccess(ctx context.Context, a0 model.NotificationInfo, a1 string) (err error) {
	// Update metrics.
	begin := s.orderCreateSuccessMetrics.Begin()
	defer func() { s.orderCreateSuccessMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.NotificationService.OrderCreateSuccess", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.OrderCreateSuccess(ctx, a0, a1)
}

func (s notificationService_local_stub) PreserveSuccess(ctx context.Context, a0 model.NotificationInfo, a1 string) (err error) {
	// Update metrics.
	begin := s.preserveSuccessMetrics.Begin()
	defer func() { s.preserveSuccessMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.NotificationService.PreserveSuccess", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PreserveSuccess(ctx, a0, a1)
}

type orderOtherService_local_stub struct {
	impl                OrderOtherService
	tracer              trace.Tracer
	getOrderByIdMetrics *codegen.MethodMetrics
	modifyOrderMetrics  *codegen.MethodMetrics
}

// Check that orderOtherService_local_stub implements the OrderOtherService interface.
var _ OrderOtherService = (*orderOtherService_local_stub)(nil)

func (s orderOtherService_local_stub) GetOrderById(ctx context.Context, a0 string, a1 string) (r0 model.Order, err error) {
	// Update metrics.
	begin := s.getOrderByIdMetrics.Begin()
	defer func() { s.getOrderByIdMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.OrderOtherService.GetOrderById", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetOrderById(ctx, a0, a1)
}

func (s orderOtherService_local_stub) ModifyOrder(ctx context.Context, a0 string, a1 uint16, a2 string) (r0 model.Order, err error) {
	// Update metrics.
	begin := s.modifyOrderMetrics.Begin()
	defer func() { s.modifyOrderMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.OrderOtherService.ModifyOrder", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.ModifyOrder(ctx, a0, a1, a2)
}

type orderService_local_stub struct {
	impl                OrderService
	tracer              trace.Tracer
	getOrderByIdMetrics *codegen.MethodMetrics
	modifyOrderMetrics  *codegen.MethodMetrics
}

// Check that orderService_local_stub implements the OrderService interface.
var _ OrderService = (*orderService_local_stub)(nil)

func (s orderService_local_stub) GetOrderById(ctx context.Context, a0 string, a1 string) (r0 model.Order, err error) {
	// Update metrics.
	begin := s.getOrderByIdMetrics.Begin()
	defer func() { s.getOrderByIdMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.OrderService.GetOrderById", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetOrderById(ctx, a0, a1)
}

func (s orderService_local_stub) ModifyOrder(ctx context.Context, a0 string, a1 uint16, a2 string) (r0 model.Order, err error) {
	// Update metrics.
	begin := s.modifyOrderMetrics.Begin()
	defer func() { s.modifyOrderMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.OrderService.ModifyOrder", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.ModifyOrder(ctx, a0, a1, a2)
}

type paymentService_local_stub struct {
	impl       PaymentService
	tracer     trace.Tracer
	payMetrics *codegen.MethodMetrics
}

// Check that paymentService_local_stub implements the PaymentService interface.
var _ PaymentService = (*paymentService_local_stub)(nil)

func (s paymentService_local_stub) Pay(ctx context.Context, a0 string, a1 string, a2 string, a3 string) (r0 model.Payment, err error) {
	// Update metrics.
	begin := s.payMetrics.Begin()
	defer func() { s.payMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.PaymentService.Pay", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.Pay(ctx, a0, a1, a2, a3)
}

type priceService_local_stub struct {
	impl          PriceService
	tracer        trace.Tracer
	createMetrics *codegen.MethodMetrics
}

// Check that priceService_local_stub implements the PriceService interface.
var _ PriceService = (*priceService_local_stub)(nil)

func (s priceService_local_stub) Create(ctx context.Context, a0 model.PriceConfig, a1 string) (r0 model.PriceConfig, err error) {
	// Update metrics.
	begin := s.createMetrics.Begin()
	defer func() { s.createMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.PriceService.Create", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.Create(ctx, a0, a1)
}

type trainService_local_stub struct {
	impl            TrainService
	tracer          trace.Tracer
	createMetrics   *codegen.MethodMetrics
	deleteMetrics   *codegen.MethodMetrics
	queryMetrics    *codegen.MethodMetrics
	retrieveMetrics *codegen.MethodMetrics
	updateMetrics   *codegen.MethodMetrics
}

// Check that trainService_local_stub implements the TrainService interface.
var _ TrainService = (*trainService_local_stub)(nil)

func (s trainService_local_stub) Create(ctx context.Context, a0 model.Train, a1 string) (r0 model.Train, err error) {
	// Update metrics.
	begin := s.createMetrics.Begin()
	defer func() { s.createMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.TrainService.Create", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.Create(ctx, a0, a1)
}

func (s trainService_local_stub) Delete(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	// Update metrics.
	begin := s.deleteMetrics.Begin()
	defer func() { s.deleteMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.TrainService.Delete", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.Delete(ctx, a0, a1)
}

func (s trainService_local_stub) Query(ctx context.Context, a0 string) (r0 []model.Train, err error) {
	// Update metrics.
	begin := s.queryMetrics.Begin()
	defer func() { s.queryMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.TrainService.Query", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.Query(ctx, a0)
}

func (s trainService_local_stub) Retrieve(ctx context.Context, a0 string, a1 string) (r0 model.Train, err error) {
	// Update metrics.
	begin := s.retrieveMetrics.Begin()
	defer func() { s.retrieveMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.TrainService.Retrieve", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.Retrieve(ctx, a0, a1)
}

func (s trainService_local_stub) Update(ctx context.Context, a0 model.Train, a1 string) (r0 model.Train, err error) {
	// Update metrics.
	begin := s.updateMetrics.Begin()
	defer func() { s.updateMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.TrainService.Update", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.Update(ctx, a0, a1)
}

type userService_local_stub struct {
	impl                     UserService
	tracer                   trace.Tracer
	deleteUserByIdMetrics    *codegen.MethodMetrics
	getAllUsersMetrics       *codegen.MethodMetrics
	getUserByIdMetrics       *codegen.MethodMetrics
	getUserByUsernameMetrics *codegen.MethodMetrics
	registerUserMetrics      *codegen.MethodMetrics
	updateUserMetrics        *codegen.MethodMetrics
}

// Check that userService_local_stub implements the UserService interface.
var _ UserService = (*userService_local_stub)(nil)

func (s userService_local_stub) DeleteUserById(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	// Update metrics.
	begin := s.deleteUserByIdMetrics.Begin()
	defer func() { s.deleteUserByIdMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.UserService.DeleteUserById", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.DeleteUserById(ctx, a0, a1)
}

func (s userService_local_stub) GetAllUsers(ctx context.Context, a0 string) (r0 []model.User, err error) {
	// Update metrics.
	begin := s.getAllUsersMetrics.Begin()
	defer func() { s.getAllUsersMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.UserService.GetAllUsers", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetAllUsers(ctx, a0)
}

func (s userService_local_stub) GetUserById(ctx context.Context, a0 string, a1 string) (r0 model.User, err error) {
	// Update metrics.
	begin := s.getUserByIdMetrics.Begin()
	defer func() { s.getUserByIdMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.UserService.GetUserById", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetUserById(ctx, a0, a1)
}

func (s userService_local_stub) GetUserByUsername(ctx context.Context, a0 string, a1 string) (r0 model.User, err error) {
	// Update metrics.
	begin := s.getUserByUsernameMetrics.Begin()
	defer func() { s.getUserByUsernameMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.UserService.GetUserByUsername", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetUserByUsername(ctx, a0, a1)
}

func (s userService_local_stub) RegisterUser(ctx context.Context, a0 model.User, a1 string) (r0 model.User, err error) {
	// Update metrics.
	begin := s.registerUserMetrics.Begin()
	defer func() { s.registerUserMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.UserService.RegisterUser", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.RegisterUser(ctx, a0, a1)
}

func (s userService_local_stub) UpdateUser(ctx context.Context, a0 model.User, a1 string) (r0 model.User, err error) {
	// Update metrics.
	begin := s.updateUserMetrics.Begin()
	defer func() { s.updateUserMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "services.UserService.UpdateUser", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.UpdateUser(ctx, a0, a1)
}

// Client stub implementations.

type adminBasicInfoService_client_stub struct {
	stub                  codegen.Stub
	addContactsMetrics    *codegen.MethodMetrics
	addPriceMetrics       *codegen.MethodMetrics
	addTrainMetrics       *codegen.MethodMetrics
	deleteContactsMetrics *codegen.MethodMetrics
	deleteTrainMetrics    *codegen.MethodMetrics
	getAllContactsMetrics *codegen.MethodMetrics
	getAllTrainsMetrics   *codegen.MethodMetrics
	modifyContactsMetrics *codegen.MethodMetrics
	modifyTrainMetrics    *codegen.MethodMetrics
}

// Check that adminBasicInfoService_client_stub implements the AdminBasicInfoService interface.
var _ AdminBasicInfoService = (*adminBasicInfoService_client_stub)(nil)

func (s adminBasicInfoService_client_stub) AddContacts(ctx context.Context, a0 model.Contact, a1 string) (r0 model.Contact, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.addContactsMetrics.Begin()
	defer func() { s.addContactsMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.AdminBasicInfoService.AddContacts", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s adminBasicInfoService_client_stub) AddPrice(ctx context.Context, a0 model.PriceConfig, a1 string) (r0 model.PriceConfig, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.addPriceMetrics.Begin()
	defer func() { s.addPriceMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.AdminBasicInfoService.AddPrice", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s adminBasicInfoService_client_stub) AddTrain(ctx context.Context, a0 model.Train, a1 string) (r0 model.Train, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.addTrainMetrics.Begin()
	defer func() { s.addTrainMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.AdminBasicInfoService.AddTrain", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 2, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s adminBasicInfoService_client_stub) DeleteContacts(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.deleteContactsMetrics.Begin()
	defer func() { s.deleteContactsMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.AdminBasicInfoService.DeleteContacts", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 3, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.String()
	err = dec.Error()
	return
}

func (s adminBasicInfoService_client_stub) DeleteTrain(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.deleteTrainMetrics.Begin()
	defer func() { s.deleteTrainMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.AdminBasicInfoService.DeleteTrain", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 4, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.String()
	err = dec.Error()
	return
}

func (s adminBasicInfoService_client_stub) GetAllContacts(ctx context.Context, a0 string) (r0 []model.Contact, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getAllContactsMetrics.Begin()
	defer func() { s.getAllContactsMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.AdminBasicInfoService.GetAllContacts", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 5, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_slice_Contact_1a3f841d(dec)
	err = dec.Error()
	return
}

func (s adminBasicInfoService_client_stub) GetAllTrains(ctx context.Context, a0 string) (r0 []model.Train, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getAllTrainsMetrics.Begin()
	defer func() { s.getAllTrainsMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.AdminBasicInfoService.GetAllTrains", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 6, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_slice_Train_98f98bc4(dec)
	err = dec.Error()
	return
}

func (s adminBasicInfoService_client_stub) ModifyContacts(ctx context.Context, a0 model.Contact, a1 string) (r0 model.Contact, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.modifyContactsMetrics.Begin()
	defer func() { s.modifyContactsMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.AdminBasicInfoService.ModifyContacts", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 7, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s adminBasicInfoService_client_stub) ModifyTrain(ctx context.Context, a0 model.Train, a1 string) (r0 model.Train, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.modifyTrainMetrics.Begin()
	defer func() { s.modifyTrainMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.AdminBasicInfoService.ModifyTrain", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 8, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

type adminOrderService_client_stub struct {
	stub codegen.Stub
}

// Check that adminOrderService_client_stub implements the AdminOrderService interface.
var _ AdminOrderService = (*adminOrderService_client_stub)(nil)

type adminUserService_client_stub struct {
	stub               codegen.Stub
	addUserMetrics     *codegen.MethodMetrics
	deleteUserMetrics  *codegen.MethodMetrics
	getAllUsersMetrics *codegen.MethodMetrics
	updateUserMetrics  *codegen.MethodMetrics
}

// Check that adminUserService_client_stub implements the AdminUserService interface.
var _ AdminUserService = (*adminUserService_client_stub)(nil)

func (s adminUserService_client_stub) AddUser(ctx context.Context, a0 model.User, a1 string) (r0 model.User, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.addUserMetrics.Begin()
	defer func() { s.addUserMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.AdminUserService.AddUser", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s adminUserService_client_stub) DeleteUser(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.deleteUserMetrics.Begin()
	defer func() { s.deleteUserMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.AdminUserService.DeleteUser", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.String()
	err = dec.Error()
	return
}

func (s adminUserService_client_stub) GetAllUsers(ctx context.Context, a0 string) (r0 []model.User, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getAllUsersMetrics.Begin()
	defer func() { s.getAllUsersMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.AdminUserService.GetAllUsers", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 2, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_slice_User_e80a5e14(dec)
	err = dec.Error()
	return
}

func (s adminUserService_client_stub) UpdateUser(ctx context.Context, a0 model.User, a1 string) (r0 model.User, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.updateUserMetrics.Begin()
	defer func() { s.updateUserMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.AdminUserService.UpdateUser", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 3, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

type authService_client_stub struct {
	stub                     codegen.Stub
	createDefaultUserMetrics *codegen.MethodMetrics
	loginMetrics             *codegen.MethodMetrics
}

// Check that authService_client_stub implements the AuthService interface.
var _ AuthService = (*authService_client_stub)(nil)

func (s authService_client_stub) CreateDefaultUser(ctx context.Context, a0 model.User, a1 string) (r0 string, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.createDefaultUserMetrics.Begin()
	defer func() { s.createDefaultUserMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.AuthService.CreateDefaultUser", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.String()
	err = dec.Error()
	return
}

func (s authService_client_stub) Login(ctx context.Context, a0 string, a1 string, a2 string, a3 model.Captcha) (r0 string, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.loginMetrics.Begin()
	defer func() { s.loginMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.AuthService.Login", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	enc.String(a0)
	enc.String(a1)
	enc.String(a2)
	(a3).WeaverMarshal(enc)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.String()
	err = dec.Error()
	return
}

type cancelService_client_stub struct {
	stub                              codegen.Stub
	calculateMetrics                  *codegen.MethodMetrics
	cancelTicketMetrics               *codegen.MethodMetrics
	getConsistencyWindowValuesMetrics *codegen.MethodMetrics
}

// Check that cancelService_client_stub implements the CancelService interface.
var _ CancelService = (*cancelService_client_stub)(nil)

func (s cancelService_client_stub) Calculate(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.calculateMetrics.Begin()
	defer func() { s.calculateMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.CancelService.Calculate", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.String()
	err = dec.Error()
	return
}

func (s cancelService_client_stub) CancelTicket(ctx context.Context, a0 string, a1 string, a2 string) (r0 string, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.cancelTicketMetrics.Begin()
	defer func() { s.cancelTicketMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.CancelService.CancelTicket", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	size += (4 + len(a2))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	enc.String(a2)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.String()
	err = dec.Error()
	return
}

func (s cancelService_client_stub) GetConsistencyWindowValues(ctx context.Context) (r0 []float64, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getConsistencyWindowValuesMetrics.Begin()
	defer func() { s.getConsistencyWindowValuesMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.CancelService.GetConsistencyWindowValues", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	var shardKey uint64

	// Call the remote method.
	var results []byte
	results, err = s.stub.Run(ctx, 2, nil, shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_slice_float64_946dd0da(dec)
	err = dec.Error()
	return
}

type contactService_client_stub struct {
	stub                           codegen.Stub
	createNewContactsMetrics       *codegen.MethodMetrics
	createNewContactsAdminMetrics  *codegen.MethodMetrics
	deleteContactsMetrics          *codegen.MethodMetrics
	findContactsByAccountIdMetrics *codegen.MethodMetrics
	getAllContactsMetrics          *codegen.MethodMetrics
	getContactsByContactIdMetrics  *codegen.MethodMetrics
	modifyContactsMetrics          *codegen.MethodMetrics
}

// Check that contactService_client_stub implements the ContactService interface.
var _ ContactService = (*contactService_client_stub)(nil)

func (s contactService_client_stub) CreateNewContacts(ctx context.Context, a0 model.Contact, a1 string) (r0 model.Contact, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.createNewContactsMetrics.Begin()
	defer func() { s.createNewContactsMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.ContactService.CreateNewContacts", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s contactService_client_stub) CreateNewContactsAdmin(ctx context.Context, a0 model.Contact, a1 string) (r0 model.Contact, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.createNewContactsAdminMetrics.Begin()
	defer func() { s.createNewContactsAdminMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.ContactService.CreateNewContactsAdmin", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s contactService_client_stub) DeleteContacts(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.deleteContactsMetrics.Begin()
	defer func() { s.deleteContactsMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.ContactService.DeleteContacts", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 2, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.String()
	err = dec.Error()
	return
}

func (s contactService_client_stub) FindContactsByAccountId(ctx context.Context, a0 string, a1 string) (r0 []model.Contact, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.findContactsByAccountIdMetrics.Begin()
	defer func() { s.findContactsByAccountIdMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.ContactService.FindContactsByAccountId", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 3, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_slice_Contact_1a3f841d(dec)
	err = dec.Error()
	return
}

func (s contactService_client_stub) GetAllContacts(ctx context.Context, a0 string) (r0 []model.Contact, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getAllContactsMetrics.Begin()
	defer func() { s.getAllContactsMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.ContactService.GetAllContacts", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 4, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_slice_Contact_1a3f841d(dec)
	err = dec.Error()
	return
}

func (s contactService_client_stub) GetContactsByContactId(ctx context.Context, a0 string, a1 string) (r0 model.Contact, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getContactsByContactIdMetrics.Begin()
	defer func() { s.getContactsByContactIdMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.ContactService.GetContactsByContactId", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 5, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s contactService_client_stub) ModifyContacts(ctx context.Context, a0 model.Contact, a1 string) (r0 model.Contact, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.modifyContactsMetrics.Begin()
	defer func() { s.modifyContactsMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.ContactService.ModifyContacts", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 6, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

type insidePaymentService_client_stub struct {
	stub            codegen.Stub
	drawBackMetrics *codegen.MethodMetrics
}

// Check that insidePaymentService_client_stub implements the InsidePaymentService interface.
var _ InsidePaymentService = (*insidePaymentService_client_stub)(nil)

func (s insidePaymentService_client_stub) DrawBack(ctx context.Context, a0 string, a1 string, a2 string) (r0 string, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.drawBackMetrics.Begin()
	defer func() { s.drawBackMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.InsidePaymentService.DrawBack", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	size += (4 + len(a2))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	enc.String(a2)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.String()
	err = dec.Error()
	return
}

type notificationService_client_stub struct {
	stub                       codegen.Stub
	orderCancelSuccessMetrics  *codegen.MethodMetrics
	orderChangedSuccessMetrics *codegen.MethodMetrics
	orderCreateSuccessMetrics  *codegen.MethodMetrics
	preserveSuccessMetrics     *codegen.MethodMetrics
}

// Check that notificationService_client_stub implements the NotificationService interface.
var _ NotificationService = (*notificationService_client_stub)(nil)

func (s notificationService_client_stub) OrderCancelSuccess(ctx context.Context, a0 model.NotificationInfo, a1 string) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.orderCancelSuccessMetrics.Begin()
	defer func() { s.orderCancelSuccessMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.NotificationService.OrderCancelSuccess", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s notificationService_client_stub) OrderChangedSuccess(ctx context.Context, a0 model.NotificationInfo, a1 string) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.orderChangedSuccessMetrics.Begin()
	defer func() { s.orderChangedSuccessMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.NotificationService.OrderChangedSuccess", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s notificationService_client_stub) OrderCreateSuccess(ctx context.Context, a0 model.NotificationInfo, a1 string) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.orderCreateSuccessMetrics.Begin()
	defer func() { s.orderCreateSuccessMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.NotificationService.OrderCreateSuccess", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 2, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s notificationService_client_stub) PreserveSuccess(ctx context.Context, a0 model.NotificationInfo, a1 string) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.preserveSuccessMetrics.Begin()
	defer func() { s.preserveSuccessMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.NotificationService.PreserveSuccess", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 3, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

type orderOtherService_client_stub struct {
	stub                codegen.Stub
	getOrderByIdMetrics *codegen.MethodMetrics
	modifyOrderMetrics  *codegen.MethodMetrics
}

// Check that orderOtherService_client_stub implements the OrderOtherService interface.
var _ OrderOtherService = (*orderOtherService_client_stub)(nil)

func (s orderOtherService_client_stub) GetOrderById(ctx context.Context, a0 string, a1 string) (r0 model.Order, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getOrderByIdMetrics.Begin()
	defer func() { s.getOrderByIdMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.OrderOtherService.GetOrderById", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s orderOtherService_client_stub) ModifyOrder(ctx context.Context, a0 string, a1 uint16, a2 string) (r0 model.Order, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.modifyOrderMetrics.Begin()
	defer func() { s.modifyOrderMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.OrderOtherService.ModifyOrder", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += 2
	size += (4 + len(a2))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.Uint16(a1)
	enc.String(a2)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

type orderService_client_stub struct {
	stub                codegen.Stub
	getOrderByIdMetrics *codegen.MethodMetrics
	modifyOrderMetrics  *codegen.MethodMetrics
}

// Check that orderService_client_stub implements the OrderService interface.
var _ OrderService = (*orderService_client_stub)(nil)

func (s orderService_client_stub) GetOrderById(ctx context.Context, a0 string, a1 string) (r0 model.Order, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getOrderByIdMetrics.Begin()
	defer func() { s.getOrderByIdMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.OrderService.GetOrderById", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s orderService_client_stub) ModifyOrder(ctx context.Context, a0 string, a1 uint16, a2 string) (r0 model.Order, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.modifyOrderMetrics.Begin()
	defer func() { s.modifyOrderMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.OrderService.ModifyOrder", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += 2
	size += (4 + len(a2))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.Uint16(a1)
	enc.String(a2)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

type paymentService_client_stub struct {
	stub       codegen.Stub
	payMetrics *codegen.MethodMetrics
}

// Check that paymentService_client_stub implements the PaymentService interface.
var _ PaymentService = (*paymentService_client_stub)(nil)

func (s paymentService_client_stub) Pay(ctx context.Context, a0 string, a1 string, a2 string, a3 string) (r0 model.Payment, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.payMetrics.Begin()
	defer func() { s.payMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.PaymentService.Pay", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	size += (4 + len(a2))
	size += (4 + len(a3))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	enc.String(a2)
	enc.String(a3)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

type priceService_client_stub struct {
	stub          codegen.Stub
	createMetrics *codegen.MethodMetrics
}

// Check that priceService_client_stub implements the PriceService interface.
var _ PriceService = (*priceService_client_stub)(nil)

func (s priceService_client_stub) Create(ctx context.Context, a0 model.PriceConfig, a1 string) (r0 model.PriceConfig, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.createMetrics.Begin()
	defer func() { s.createMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.PriceService.Create", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

type trainService_client_stub struct {
	stub            codegen.Stub
	createMetrics   *codegen.MethodMetrics
	deleteMetrics   *codegen.MethodMetrics
	queryMetrics    *codegen.MethodMetrics
	retrieveMetrics *codegen.MethodMetrics
	updateMetrics   *codegen.MethodMetrics
}

// Check that trainService_client_stub implements the TrainService interface.
var _ TrainService = (*trainService_client_stub)(nil)

func (s trainService_client_stub) Create(ctx context.Context, a0 model.Train, a1 string) (r0 model.Train, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.createMetrics.Begin()
	defer func() { s.createMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.TrainService.Create", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s trainService_client_stub) Delete(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.deleteMetrics.Begin()
	defer func() { s.deleteMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.TrainService.Delete", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.String()
	err = dec.Error()
	return
}

func (s trainService_client_stub) Query(ctx context.Context, a0 string) (r0 []model.Train, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.queryMetrics.Begin()
	defer func() { s.queryMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.TrainService.Query", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 2, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_slice_Train_98f98bc4(dec)
	err = dec.Error()
	return
}

func (s trainService_client_stub) Retrieve(ctx context.Context, a0 string, a1 string) (r0 model.Train, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.retrieveMetrics.Begin()
	defer func() { s.retrieveMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.TrainService.Retrieve", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 3, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s trainService_client_stub) Update(ctx context.Context, a0 model.Train, a1 string) (r0 model.Train, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.updateMetrics.Begin()
	defer func() { s.updateMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.TrainService.Update", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 4, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

type userService_client_stub struct {
	stub                     codegen.Stub
	deleteUserByIdMetrics    *codegen.MethodMetrics
	getAllUsersMetrics       *codegen.MethodMetrics
	getUserByIdMetrics       *codegen.MethodMetrics
	getUserByUsernameMetrics *codegen.MethodMetrics
	registerUserMetrics      *codegen.MethodMetrics
	updateUserMetrics        *codegen.MethodMetrics
}

// Check that userService_client_stub implements the UserService interface.
var _ UserService = (*userService_client_stub)(nil)

func (s userService_client_stub) DeleteUserById(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.deleteUserByIdMetrics.Begin()
	defer func() { s.deleteUserByIdMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.UserService.DeleteUserById", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.String()
	err = dec.Error()
	return
}

func (s userService_client_stub) GetAllUsers(ctx context.Context, a0 string) (r0 []model.User, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getAllUsersMetrics.Begin()
	defer func() { s.getAllUsersMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.UserService.GetAllUsers", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_slice_User_e80a5e14(dec)
	err = dec.Error()
	return
}

func (s userService_client_stub) GetUserById(ctx context.Context, a0 string, a1 string) (r0 model.User, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getUserByIdMetrics.Begin()
	defer func() { s.getUserByIdMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.UserService.GetUserById", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 2, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s userService_client_stub) GetUserByUsername(ctx context.Context, a0 string, a1 string) (r0 model.User, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getUserByUsernameMetrics.Begin()
	defer func() { s.getUserByUsernameMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.UserService.GetUserByUsername", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 3, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s userService_client_stub) RegisterUser(ctx context.Context, a0 model.User, a1 string) (r0 model.User, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.registerUserMetrics.Begin()
	defer func() { s.registerUserMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.UserService.RegisterUser", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 4, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s userService_client_stub) UpdateUser(ctx context.Context, a0 model.User, a1 string) (r0 model.User, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.updateUserMetrics.Begin()
	defer func() { s.updateUserMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "services.UserService.UpdateUser", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(xcweaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 5, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(xcweaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

// Note that "xcweaver generate" will always generate the error message below.
// Everything is okay. The error message is only relevant if you see it when
// you run "go build" or "go run".
var _ codegen.LatestVersion = codegen.Version[[0][20]struct{}](`

ERROR: You generated this file with 'xcweaver generate' v0.5.47 (codegen
version v0.20.0). The generated code is incompatible with the version of the
github.com/TiagoMalhadas/xcweaver module that you're using. The xcweaver module
version can be found in your go.mod file or by running the following command.

    go list -m github.com/TiagoMalhadas/xcweaver

We recommend updating the xcweaver module and the 'xcweaver generate' command by
running the following.

    go get github.com/TiagoMalhadas/xcweaver@latest
    go install github.com/TiagoMalhadas/xcweaver/cmd/weaver@latest

Then, re-run 'xcweaver generate' and re-build your code. If the problem persists,
please file an issue at https://github.com/TiagoMalhadas/xcweaver/issues.

`)

// Server stub implementations.

type adminBasicInfoService_server_stub struct {
	impl    AdminBasicInfoService
	addLoad func(key uint64, load float64)
}

// Check that adminBasicInfoService_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*adminBasicInfoService_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s adminBasicInfoService_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "AddContacts":
		return s.addContacts
	case "AddPrice":
		return s.addPrice
	case "AddTrain":
		return s.addTrain
	case "DeleteContacts":
		return s.deleteContacts
	case "DeleteTrain":
		return s.deleteTrain
	case "GetAllContacts":
		return s.getAllContacts
	case "GetAllTrains":
		return s.getAllTrains
	case "ModifyContacts":
		return s.modifyContacts
	case "ModifyTrain":
		return s.modifyTrain
	default:
		return nil
	}
}

func (s adminBasicInfoService_server_stub) addContacts(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 model.Contact
	(&a0).WeaverUnmarshal(dec)
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.AddContacts(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s adminBasicInfoService_server_stub) addPrice(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 model.PriceConfig
	(&a0).WeaverUnmarshal(dec)
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.AddPrice(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s adminBasicInfoService_server_stub) addTrain(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 model.Train
	(&a0).WeaverUnmarshal(dec)
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.AddTrain(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s adminBasicInfoService_server_stub) deleteContacts(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.DeleteContacts(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.String(r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s adminBasicInfoService_server_stub) deleteTrain(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.DeleteTrain(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.String(r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s adminBasicInfoService_server_stub) getAllContacts(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.GetAllContacts(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_Contact_1a3f841d(enc, r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s adminBasicInfoService_server_stub) getAllTrains(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.GetAllTrains(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_Train_98f98bc4(enc, r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s adminBasicInfoService_server_stub) modifyContacts(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 model.Contact
	(&a0).WeaverUnmarshal(dec)
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.ModifyContacts(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s adminBasicInfoService_server_stub) modifyTrain(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 model.Train
	(&a0).WeaverUnmarshal(dec)
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.ModifyTrain(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

type adminOrderService_server_stub struct {
	impl    AdminOrderService
	addLoad func(key uint64, load float64)
}

// Check that adminOrderService_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*adminOrderService_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s adminOrderService_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	default:
		return nil
	}
}

type adminUserService_server_stub struct {
	impl    AdminUserService
	addLoad func(key uint64, load float64)
}

// Check that adminUserService_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*adminUserService_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s adminUserService_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "AddUser":
		return s.addUser
	case "DeleteUser":
		return s.deleteUser
	case "GetAllUsers":
		return s.getAllUsers
	case "UpdateUser":
		return s.updateUser
	default:
		return nil
	}
}

func (s adminUserService_server_stub) addUser(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 model.User
	(&a0).WeaverUnmarshal(dec)
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.AddUser(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s adminUserService_server_stub) deleteUser(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.DeleteUser(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.String(r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s adminUserService_server_stub) getAllUsers(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.GetAllUsers(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_User_e80a5e14(enc, r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s adminUserService_server_stub) updateUser(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 model.User
	(&a0).WeaverUnmarshal(dec)
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.UpdateUser(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

type authService_server_stub struct {
	impl    AuthService
	addLoad func(key uint64, load float64)
}

// Check that authService_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*authService_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s authService_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "CreateDefaultUser":
		return s.createDefaultUser
	case "Login":
		return s.login
	default:
		return nil
	}
}

func (s authService_server_stub) createDefaultUser(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 model.User
	(&a0).WeaverUnmarshal(dec)
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.CreateDefaultUser(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.String(r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s authService_server_stub) login(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()
	var a2 string
	a2 = dec.String()
	var a3 model.Captcha
	(&a3).WeaverUnmarshal(dec)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.Login(ctx, a0, a1, a2, a3)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.String(r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

type cancelService_server_stub struct {
	impl    CancelService
	addLoad func(key uint64, load float64)
}

// Check that cancelService_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*cancelService_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s cancelService_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "Calculate":
		return s.calculate
	case "CancelTicket":
		return s.cancelTicket
	case "GetConsistencyWindowValues":
		return s.getConsistencyWindowValues
	default:
		return nil
	}
}

func (s cancelService_server_stub) calculate(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.Calculate(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.String(r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s cancelService_server_stub) cancelTicket(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()
	var a2 string
	a2 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.CancelTicket(ctx, a0, a1, a2)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.String(r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s cancelService_server_stub) getConsistencyWindowValues(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.GetConsistencyWindowValues(ctx)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_float64_946dd0da(enc, r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

type contactService_server_stub struct {
	impl    ContactService
	addLoad func(key uint64, load float64)
}

// Check that contactService_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*contactService_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s contactService_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "CreateNewContacts":
		return s.createNewContacts
	case "CreateNewContactsAdmin":
		return s.createNewContactsAdmin
	case "DeleteContacts":
		return s.deleteContacts
	case "FindContactsByAccountId":
		return s.findContactsByAccountId
	case "GetAllContacts":
		return s.getAllContacts
	case "GetContactsByContactId":
		return s.getContactsByContactId
	case "ModifyContacts":
		return s.modifyContacts
	default:
		return nil
	}
}

func (s contactService_server_stub) createNewContacts(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 model.Contact
	(&a0).WeaverUnmarshal(dec)
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.CreateNewContacts(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s contactService_server_stub) createNewContactsAdmin(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 model.Contact
	(&a0).WeaverUnmarshal(dec)
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.CreateNewContactsAdmin(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s contactService_server_stub) deleteContacts(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.DeleteContacts(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.String(r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s contactService_server_stub) findContactsByAccountId(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.FindContactsByAccountId(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_Contact_1a3f841d(enc, r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s contactService_server_stub) getAllContacts(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.GetAllContacts(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_Contact_1a3f841d(enc, r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s contactService_server_stub) getContactsByContactId(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.GetContactsByContactId(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s contactService_server_stub) modifyContacts(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 model.Contact
	(&a0).WeaverUnmarshal(dec)
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.ModifyContacts(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

type insidePaymentService_server_stub struct {
	impl    InsidePaymentService
	addLoad func(key uint64, load float64)
}

// Check that insidePaymentService_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*insidePaymentService_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s insidePaymentService_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "DrawBack":
		return s.drawBack
	default:
		return nil
	}
}

func (s insidePaymentService_server_stub) drawBack(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()
	var a2 string
	a2 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.DrawBack(ctx, a0, a1, a2)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.String(r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

type notificationService_server_stub struct {
	impl    NotificationService
	addLoad func(key uint64, load float64)
}

// Check that notificationService_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*notificationService_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s notificationService_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "OrderCancelSuccess":
		return s.orderCancelSuccess
	case "OrderChangedSuccess":
		return s.orderChangedSuccess
	case "OrderCreateSuccess":
		return s.orderCreateSuccess
	case "PreserveSuccess":
		return s.preserveSuccess
	default:
		return nil
	}
}

func (s notificationService_server_stub) orderCancelSuccess(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 model.NotificationInfo
	(&a0).WeaverUnmarshal(dec)
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.OrderCancelSuccess(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s notificationService_server_stub) orderChangedSuccess(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 model.NotificationInfo
	(&a0).WeaverUnmarshal(dec)
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.OrderChangedSuccess(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s notificationService_server_stub) orderCreateSuccess(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 model.NotificationInfo
	(&a0).WeaverUnmarshal(dec)
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.OrderCreateSuccess(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s notificationService_server_stub) preserveSuccess(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 model.NotificationInfo
	(&a0).WeaverUnmarshal(dec)
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.PreserveSuccess(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

type orderOtherService_server_stub struct {
	impl    OrderOtherService
	addLoad func(key uint64, load float64)
}

// Check that orderOtherService_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*orderOtherService_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s orderOtherService_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "GetOrderById":
		return s.getOrderById
	case "ModifyOrder":
		return s.modifyOrder
	default:
		return nil
	}
}

func (s orderOtherService_server_stub) getOrderById(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.GetOrderById(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s orderOtherService_server_stub) modifyOrder(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 uint16
	a1 = dec.Uint16()
	var a2 string
	a2 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.ModifyOrder(ctx, a0, a1, a2)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

type orderService_server_stub struct {
	impl    OrderService
	addLoad func(key uint64, load float64)
}

// Check that orderService_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*orderService_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s orderService_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "GetOrderById":
		return s.getOrderById
	case "ModifyOrder":
		return s.modifyOrder
	default:
		return nil
	}
}

func (s orderService_server_stub) getOrderById(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.GetOrderById(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s orderService_server_stub) modifyOrder(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 uint16
	a1 = dec.Uint16()
	var a2 string
	a2 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.ModifyOrder(ctx, a0, a1, a2)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

type paymentService_server_stub struct {
	impl    PaymentService
	addLoad func(key uint64, load float64)
}

// Check that paymentService_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*paymentService_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s paymentService_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "Pay":
		return s.pay
	default:
		return nil
	}
}

func (s paymentService_server_stub) pay(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()
	var a2 string
	a2 = dec.String()
	var a3 string
	a3 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.Pay(ctx, a0, a1, a2, a3)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

type priceService_server_stub struct {
	impl    PriceService
	addLoad func(key uint64, load float64)
}

// Check that priceService_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*priceService_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s priceService_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "Create":
		return s.create
	default:
		return nil
	}
}

func (s priceService_server_stub) create(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 model.PriceConfig
	(&a0).WeaverUnmarshal(dec)
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.Create(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

type trainService_server_stub struct {
	impl    TrainService
	addLoad func(key uint64, load float64)
}

// Check that trainService_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*trainService_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s trainService_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "Create":
		return s.create
	case "Delete":
		return s.delete
	case "Query":
		return s.query
	case "Retrieve":
		return s.retrieve
	case "Update":
		return s.update
	default:
		return nil
	}
}

func (s trainService_server_stub) create(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 model.Train
	(&a0).WeaverUnmarshal(dec)
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.Create(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s trainService_server_stub) delete(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.Delete(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.String(r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s trainService_server_stub) query(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.Query(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_Train_98f98bc4(enc, r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s trainService_server_stub) retrieve(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.Retrieve(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s trainService_server_stub) update(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 model.Train
	(&a0).WeaverUnmarshal(dec)
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.Update(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

type userService_server_stub struct {
	impl    UserService
	addLoad func(key uint64, load float64)
}

// Check that userService_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*userService_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s userService_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "DeleteUserById":
		return s.deleteUserById
	case "GetAllUsers":
		return s.getAllUsers
	case "GetUserById":
		return s.getUserById
	case "GetUserByUsername":
		return s.getUserByUsername
	case "RegisterUser":
		return s.registerUser
	case "UpdateUser":
		return s.updateUser
	default:
		return nil
	}
}

func (s userService_server_stub) deleteUserById(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.DeleteUserById(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.String(r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s userService_server_stub) getAllUsers(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.GetAllUsers(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_User_e80a5e14(enc, r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s userService_server_stub) getUserById(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.GetUserById(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s userService_server_stub) getUserByUsername(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.GetUserByUsername(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s userService_server_stub) registerUser(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 model.User
	(&a0).WeaverUnmarshal(dec)
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.RegisterUser(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s userService_server_stub) updateUser(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 model.User
	(&a0).WeaverUnmarshal(dec)
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.UpdateUser(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

// Reflect stub implementations.

type adminBasicInfoService_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that adminBasicInfoService_reflect_stub implements the AdminBasicInfoService interface.
var _ AdminBasicInfoService = (*adminBasicInfoService_reflect_stub)(nil)

func (s adminBasicInfoService_reflect_stub) AddContacts(ctx context.Context, a0 model.Contact, a1 string) (r0 model.Contact, err error) {
	err = s.caller("AddContacts", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s adminBasicInfoService_reflect_stub) AddPrice(ctx context.Context, a0 model.PriceConfig, a1 string) (r0 model.PriceConfig, err error) {
	err = s.caller("AddPrice", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s adminBasicInfoService_reflect_stub) AddTrain(ctx context.Context, a0 model.Train, a1 string) (r0 model.Train, err error) {
	err = s.caller("AddTrain", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s adminBasicInfoService_reflect_stub) DeleteContacts(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	err = s.caller("DeleteContacts", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s adminBasicInfoService_reflect_stub) DeleteTrain(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	err = s.caller("DeleteTrain", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s adminBasicInfoService_reflect_stub) GetAllContacts(ctx context.Context, a0 string) (r0 []model.Contact, err error) {
	err = s.caller("GetAllContacts", ctx, []any{a0}, []any{&r0})
	return
}

func (s adminBasicInfoService_reflect_stub) GetAllTrains(ctx context.Context, a0 string) (r0 []model.Train, err error) {
	err = s.caller("GetAllTrains", ctx, []any{a0}, []any{&r0})
	return
}

func (s adminBasicInfoService_reflect_stub) ModifyContacts(ctx context.Context, a0 model.Contact, a1 string) (r0 model.Contact, err error) {
	err = s.caller("ModifyContacts", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s adminBasicInfoService_reflect_stub) ModifyTrain(ctx context.Context, a0 model.Train, a1 string) (r0 model.Train, err error) {
	err = s.caller("ModifyTrain", ctx, []any{a0, a1}, []any{&r0})
	return
}

type adminOrderService_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that adminOrderService_reflect_stub implements the AdminOrderService interface.
var _ AdminOrderService = (*adminOrderService_reflect_stub)(nil)

type adminUserService_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that adminUserService_reflect_stub implements the AdminUserService interface.
var _ AdminUserService = (*adminUserService_reflect_stub)(nil)

func (s adminUserService_reflect_stub) AddUser(ctx context.Context, a0 model.User, a1 string) (r0 model.User, err error) {
	err = s.caller("AddUser", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s adminUserService_reflect_stub) DeleteUser(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	err = s.caller("DeleteUser", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s adminUserService_reflect_stub) GetAllUsers(ctx context.Context, a0 string) (r0 []model.User, err error) {
	err = s.caller("GetAllUsers", ctx, []any{a0}, []any{&r0})
	return
}

func (s adminUserService_reflect_stub) UpdateUser(ctx context.Context, a0 model.User, a1 string) (r0 model.User, err error) {
	err = s.caller("UpdateUser", ctx, []any{a0, a1}, []any{&r0})
	return
}

type authService_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that authService_reflect_stub implements the AuthService interface.
var _ AuthService = (*authService_reflect_stub)(nil)

func (s authService_reflect_stub) CreateDefaultUser(ctx context.Context, a0 model.User, a1 string) (r0 string, err error) {
	err = s.caller("CreateDefaultUser", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s authService_reflect_stub) Login(ctx context.Context, a0 string, a1 string, a2 string, a3 model.Captcha) (r0 string, err error) {
	err = s.caller("Login", ctx, []any{a0, a1, a2, a3}, []any{&r0})
	return
}

type cancelService_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that cancelService_reflect_stub implements the CancelService interface.
var _ CancelService = (*cancelService_reflect_stub)(nil)

func (s cancelService_reflect_stub) Calculate(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	err = s.caller("Calculate", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s cancelService_reflect_stub) CancelTicket(ctx context.Context, a0 string, a1 string, a2 string) (r0 string, err error) {
	err = s.caller("CancelTicket", ctx, []any{a0, a1, a2}, []any{&r0})
	return
}

func (s cancelService_reflect_stub) GetConsistencyWindowValues(ctx context.Context) (r0 []float64, err error) {
	err = s.caller("GetConsistencyWindowValues", ctx, []any{}, []any{&r0})
	return
}

type contactService_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that contactService_reflect_stub implements the ContactService interface.
var _ ContactService = (*contactService_reflect_stub)(nil)

func (s contactService_reflect_stub) CreateNewContacts(ctx context.Context, a0 model.Contact, a1 string) (r0 model.Contact, err error) {
	err = s.caller("CreateNewContacts", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s contactService_reflect_stub) CreateNewContactsAdmin(ctx context.Context, a0 model.Contact, a1 string) (r0 model.Contact, err error) {
	err = s.caller("CreateNewContactsAdmin", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s contactService_reflect_stub) DeleteContacts(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	err = s.caller("DeleteContacts", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s contactService_reflect_stub) FindContactsByAccountId(ctx context.Context, a0 string, a1 string) (r0 []model.Contact, err error) {
	err = s.caller("FindContactsByAccountId", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s contactService_reflect_stub) GetAllContacts(ctx context.Context, a0 string) (r0 []model.Contact, err error) {
	err = s.caller("GetAllContacts", ctx, []any{a0}, []any{&r0})
	return
}

func (s contactService_reflect_stub) GetContactsByContactId(ctx context.Context, a0 string, a1 string) (r0 model.Contact, err error) {
	err = s.caller("GetContactsByContactId", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s contactService_reflect_stub) ModifyContacts(ctx context.Context, a0 model.Contact, a1 string) (r0 model.Contact, err error) {
	err = s.caller("ModifyContacts", ctx, []any{a0, a1}, []any{&r0})
	return
}

type insidePaymentService_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that insidePaymentService_reflect_stub implements the InsidePaymentService interface.
var _ InsidePaymentService = (*insidePaymentService_reflect_stub)(nil)

func (s insidePaymentService_reflect_stub) DrawBack(ctx context.Context, a0 string, a1 string, a2 string) (r0 string, err error) {
	err = s.caller("DrawBack", ctx, []any{a0, a1, a2}, []any{&r0})
	return
}

type notificationService_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that notificationService_reflect_stub implements the NotificationService interface.
var _ NotificationService = (*notificationService_reflect_stub)(nil)

func (s notificationService_reflect_stub) OrderCancelSuccess(ctx context.Context, a0 model.NotificationInfo, a1 string) (err error) {
	err = s.caller("OrderCancelSuccess", ctx, []any{a0, a1}, []any{})
	return
}

func (s notificationService_reflect_stub) OrderChangedSuccess(ctx context.Context, a0 model.NotificationInfo, a1 string) (err error) {
	err = s.caller("OrderChangedSuccess", ctx, []any{a0, a1}, []any{})
	return
}

func (s notificationService_reflect_stub) OrderCreateSuccess(ctx context.Context, a0 model.NotificationInfo, a1 string) (err error) {
	err = s.caller("OrderCreateSuccess", ctx, []any{a0, a1}, []any{})
	return
}

func (s notificationService_reflect_stub) PreserveSuccess(ctx context.Context, a0 model.NotificationInfo, a1 string) (err error) {
	err = s.caller("PreserveSuccess", ctx, []any{a0, a1}, []any{})
	return
}

type orderOtherService_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that orderOtherService_reflect_stub implements the OrderOtherService interface.
var _ OrderOtherService = (*orderOtherService_reflect_stub)(nil)

func (s orderOtherService_reflect_stub) GetOrderById(ctx context.Context, a0 string, a1 string) (r0 model.Order, err error) {
	err = s.caller("GetOrderById", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s orderOtherService_reflect_stub) ModifyOrder(ctx context.Context, a0 string, a1 uint16, a2 string) (r0 model.Order, err error) {
	err = s.caller("ModifyOrder", ctx, []any{a0, a1, a2}, []any{&r0})
	return
}

type orderService_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that orderService_reflect_stub implements the OrderService interface.
var _ OrderService = (*orderService_reflect_stub)(nil)

func (s orderService_reflect_stub) GetOrderById(ctx context.Context, a0 string, a1 string) (r0 model.Order, err error) {
	err = s.caller("GetOrderById", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s orderService_reflect_stub) ModifyOrder(ctx context.Context, a0 string, a1 uint16, a2 string) (r0 model.Order, err error) {
	err = s.caller("ModifyOrder", ctx, []any{a0, a1, a2}, []any{&r0})
	return
}

type paymentService_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that paymentService_reflect_stub implements the PaymentService interface.
var _ PaymentService = (*paymentService_reflect_stub)(nil)

func (s paymentService_reflect_stub) Pay(ctx context.Context, a0 string, a1 string, a2 string, a3 string) (r0 model.Payment, err error) {
	err = s.caller("Pay", ctx, []any{a0, a1, a2, a3}, []any{&r0})
	return
}

type priceService_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that priceService_reflect_stub implements the PriceService interface.
var _ PriceService = (*priceService_reflect_stub)(nil)

func (s priceService_reflect_stub) Create(ctx context.Context, a0 model.PriceConfig, a1 string) (r0 model.PriceConfig, err error) {
	err = s.caller("Create", ctx, []any{a0, a1}, []any{&r0})
	return
}

type trainService_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that trainService_reflect_stub implements the TrainService interface.
var _ TrainService = (*trainService_reflect_stub)(nil)

func (s trainService_reflect_stub) Create(ctx context.Context, a0 model.Train, a1 string) (r0 model.Train, err error) {
	err = s.caller("Create", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s trainService_reflect_stub) Delete(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	err = s.caller("Delete", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s trainService_reflect_stub) Query(ctx context.Context, a0 string) (r0 []model.Train, err error) {
	err = s.caller("Query", ctx, []any{a0}, []any{&r0})
	return
}

func (s trainService_reflect_stub) Retrieve(ctx context.Context, a0 string, a1 string) (r0 model.Train, err error) {
	err = s.caller("Retrieve", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s trainService_reflect_stub) Update(ctx context.Context, a0 model.Train, a1 string) (r0 model.Train, err error) {
	err = s.caller("Update", ctx, []any{a0, a1}, []any{&r0})
	return
}

type userService_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that userService_reflect_stub implements the UserService interface.
var _ UserService = (*userService_reflect_stub)(nil)

func (s userService_reflect_stub) DeleteUserById(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	err = s.caller("DeleteUserById", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s userService_reflect_stub) GetAllUsers(ctx context.Context, a0 string) (r0 []model.User, err error) {
	err = s.caller("GetAllUsers", ctx, []any{a0}, []any{&r0})
	return
}

func (s userService_reflect_stub) GetUserById(ctx context.Context, a0 string, a1 string) (r0 model.User, err error) {
	err = s.caller("GetUserById", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s userService_reflect_stub) GetUserByUsername(ctx context.Context, a0 string, a1 string) (r0 model.User, err error) {
	err = s.caller("GetUserByUsername", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s userService_reflect_stub) RegisterUser(ctx context.Context, a0 model.User, a1 string) (r0 model.User, err error) {
	err = s.caller("RegisterUser", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s userService_reflect_stub) UpdateUser(ctx context.Context, a0 model.User, a1 string) (r0 model.User, err error) {
	err = s.caller("UpdateUser", ctx, []any{a0, a1}, []any{&r0})
	return
}

// Encoding/decoding implementations.

func serviceweaver_enc_slice_Contact_1a3f841d(enc *codegen.Encoder, arg []model.Contact) {
	if arg == nil {
		enc.Len(-1)
		return
	}
	enc.Len(len(arg))
	for i := 0; i < len(arg); i++ {
		(arg[i]).WeaverMarshal(enc)
	}
}

func serviceweaver_dec_slice_Contact_1a3f841d(dec *codegen.Decoder) []model.Contact {
	n := dec.Len()
	if n == -1 {
		return nil
	}
	res := make([]model.Contact, n)
	for i := 0; i < n; i++ {
		(&res[i]).WeaverUnmarshal(dec)
	}
	return res
}

func serviceweaver_enc_slice_Train_98f98bc4(enc *codegen.Encoder, arg []model.Train) {
	if arg == nil {
		enc.Len(-1)
		return
	}
	enc.Len(len(arg))
	for i := 0; i < len(arg); i++ {
		(arg[i]).WeaverMarshal(enc)
	}
}

func serviceweaver_dec_slice_Train_98f98bc4(dec *codegen.Decoder) []model.Train {
	n := dec.Len()
	if n == -1 {
		return nil
	}
	res := make([]model.Train, n)
	for i := 0; i < n; i++ {
		(&res[i]).WeaverUnmarshal(dec)
	}
	return res
}

func serviceweaver_enc_slice_User_e80a5e14(enc *codegen.Encoder, arg []model.User) {
	if arg == nil {
		enc.Len(-1)
		return
	}
	enc.Len(len(arg))
	for i := 0; i < len(arg); i++ {
		(arg[i]).WeaverMarshal(enc)
	}
}

func serviceweaver_dec_slice_User_e80a5e14(dec *codegen.Decoder) []model.User {
	n := dec.Len()
	if n == -1 {
		return nil
	}
	res := make([]model.User, n)
	for i := 0; i < n; i++ {
		(&res[i]).WeaverUnmarshal(dec)
	}
	return res
}

func serviceweaver_enc_slice_float64_946dd0da(enc *codegen.Encoder, arg []float64) {
	if arg == nil {
		enc.Len(-1)
		return
	}
	enc.Len(len(arg))
	for i := 0; i < len(arg); i++ {
		enc.Float64(arg[i])
	}
}

func serviceweaver_dec_slice_float64_946dd0da(dec *codegen.Decoder) []float64 {
	n := dec.Len()
	if n == -1 {
		return nil
	}
	res := make([]float64, n)
	for i := 0; i < n; i++ {
		res[i] = dec.Float64()
	}
	return res
}
